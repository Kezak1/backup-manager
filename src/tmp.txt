#define INOTIFY_BUF_LEN (16 * (sizeof(struct inotify_event) + NAME_MAX + 1))
#define WATCH_MASK (IN_CREATE | IN_DELETE | IN_MOVED_FROM | IN_MOVED_TO | \
                    IN_ATTRIB | IN_CLOSE_WRITE | IN_DELETE_SELF | IN_MOVE_SELF)

struct Watch {
    int wd;
    char *path;
};

struct WatchMap {
    struct Watch watch_map[MAX_TARGETS * 1024];
    int watch_count;
};

static void add_to_map(struct WatchMap *map, int wd, const char *path) {
    if (map->watch_count >= (int)(sizeof(map->watch_map)/sizeof(map->watch_map[0]))) {
        fprintf(stderr, "Exceeded max watches!\n");
        return;
    }
    map->watch_map[map->watch_count].wd = wd;
    map->watch_map[map->watch_count].path = strdup(path);
    map->watch_count++;
}

static struct Watch *find_watch(struct WatchMap *map, int wd) {
    for (int i = 0; i < map->watch_count; i++) {
        if (map->watch_map[i].wd == wd) return &map->watch_map[i];
    }
    return NULL;
}

static void remove_from_map(struct WatchMap *map, int wd) {
    for (int i = 0; i < map->watch_count; i++) {
        if (map->watch_map[i].wd == wd) {
            free(map->watch_map[i].path);
            map->watch_map[i] = map->watch_map[map->watch_count - 1];
            map->watch_count--;
            return;
        }
    }
}

static void add_watch_recursive(int notify_fd, struct WatchMap *map, const char *base_path) {
    int wd = inotify_add_watch(notify_fd, base_path, WATCH_MASK);
    if (wd < 0) {
        perror("inotify_add_watch");
        return;
    }
    add_to_map(map, wd, base_path);

    DIR *dir = opendir(base_path);
    if (!dir) {
        perror("opendir");
        return;
    }

    struct dirent *entry;
    while ((entry = readdir(dir)) != NULL) {
        if (!strcmp(entry->d_name, ".") || !strcmp(entry->d_name, "..")) continue;

        char full_path[PATH_MAX];
        snprintf(full_path, sizeof(full_path), "%s/%s", base_path, entry->d_name);

        struct stat st;
        if (lstat(full_path, &st) == 0 && S_ISDIR(st.st_mode)) {
            add_watch_recursive(notify_fd, map, full_path);
        }
    }

    closedir(dir);
}

static void update_watch_paths(struct WatchMap *map, const char *old_path, const char *new_path) {
    size_t old_len = strlen(old_path);

    for (int i = 0; i < map->watch_count; i++) {
        if (strncmp(map->watch_map[i].path, old_path, old_len) == 0 &&
            (map->watch_map[i].path[old_len] == '/' || map->watch_map[i].path[old_len] == '\0')) {

            char new_full_path[PATH_MAX];
            snprintf(new_full_path, sizeof(new_full_path), "%s%s",
                     new_path, map->watch_map[i].path + old_len);

            free(map->watch_map[i].path);
            map->watch_map[i].path = strdup(new_full_path);
        }
    }
}

static void build_target_path(const char *abs_src, const char *abs_target,
                              const char *src_path, char *out, size_t out_sz) {
    size_t src_len = strlen(abs_src);
    if (strncmp(src_path, abs_src, src_len) != 0) {
        out[0] = '\0';
        return;
    }
    snprintf(out, out_sz, "%s%s", abs_target, src_path + src_len);
}

static void mirror_create_or_update(const char *src_path, const char *dst_path,
                                    const char *abs_src, const char *abs_target) {
    struct stat st;
    if (lstat(src_path, &st) == -1) {
        if (errno != ENOENT) perror("lstat");
        return;
    }

    if (S_ISDIR(st.st_mode)) {
        checked_mkdir((char *)dst_path);
    } else if (S_ISLNK(st.st_mode)) {
        copy_symlink(src_path, dst_path, abs_src, abs_target);
    } else if (S_ISREG(st.st_mode)) {
        copy_file(src_path, dst_path);
    }
}

static void mirror_remove(const char *dst_path) {
    struct stat st;
    if (lstat(dst_path, &st) == -1) {
        if (errno != ENOENT) perror("lstat");
        return;
    }
    if (S_ISDIR(st.st_mode)) {
        if (rmdir(dst_path) == -1 && errno != ENOENT && errno != ENOTEMPTY) {
            perror("rmdir");
        }
    } else {
        if (unlink(dst_path) == -1 && errno != ENOENT) {
            perror("unlink");
        }
    }
}

static void watch_add_mirror(const char *abs_src, const char *abs_target) {
    int notify_fd = inotify_init();
    if (notify_fd < 0) ERR("inotify_init");

    struct WatchMap map = {0};
    add_watch_recursive(notify_fd, &map, abs_src);

    uint32_t pending_cookie = 0;
    char pending_move_path[PATH_MAX] = "";

    while (map.watch_count > 0) {
        char buffer[INOTIFY_BUF_LEN];
        ssize_t len = read(notify_fd, buffer, sizeof(buffer));
        if (len < 0) {
            if (errno == EINTR) continue;
            ERR("read");
        }

        for (ssize_t i = 0; i < len; ) {
            struct inotify_event *event = (struct inotify_event *)&buffer[i];
            struct Watch *watch = find_watch(&map, event->wd);

            char src_path[PATH_MAX] = "";
            if (watch) {
                if (event->len > 0) {
                    snprintf(src_path, sizeof(src_path), "%s/%s", watch->path, event->name);
                } else {
                    snprintf(src_path, sizeof(src_path), "%s", watch->path);
                }
            }

            if (event->mask & IN_IGNORED) {
                remove_from_map(&map, event->wd);
            } else if ((event->mask & (IN_DELETE_SELF | IN_MOVE_SELF)) &&
                       watch && strcmp(watch->path, abs_src) == 0) {
                close(notify_fd);
                return;
            } else {
                char dst_path[PATH_MAX] = "";
                build_target_path(abs_src, abs_target, src_path, dst_path, sizeof(dst_path));

                if (event->mask & IN_MOVED_FROM) {
                    pending_cookie = event->cookie;
                    strncpy(pending_move_path, src_path, sizeof(pending_move_path));
                }

                if (event->mask & IN_ISDIR) {
                    if (event->mask & IN_CREATE) {
                        checked_mkdir(dst_path);
                        add_watch_recursive(notify_fd, &map, src_path);
                    } else if (event->mask & IN_DELETE) {
                        mirror_remove(dst_path);
                    } else if (event->mask & IN_MOVED_TO) {
                        if (pending_cookie && event->cookie == pending_cookie) {
                            char old_dst[PATH_MAX];
                            build_target_path(abs_src, abs_target, pending_move_path, old_dst, sizeof(old_dst));
                            rename(old_dst, dst_path);
                            update_watch_paths(&map, pending_move_path, src_path);
                            pending_cookie = 0;
                            pending_move_path[0] = '\0';
                        } else {
                            checked_mkdir(dst_path);
                            add_watch_recursive(notify_fd, &map, src_path);
                        }
                    }
                } else {
                    if (event->mask & (IN_CREATE | IN_CLOSE_WRITE | IN_ATTRIB | IN_MOVED_TO)) {
                        mirror_create_or_update(src_path, dst_path, abs_src, abs_target);
                    }
                    if (event->mask & (IN_DELETE | IN_MOVED_FROM)) {
                        mirror_remove(dst_path);
                    }
                }
            }

            i += sizeof(struct inotify_event) + event->len;
        }
    }

    close(notify_fd);
}
